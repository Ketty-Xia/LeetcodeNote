
第一天: 值传递三要素将数据结构统一于DAG
值传递覆盖力扣80%以上的题目
最后一天:算法统一于动态规划



Day 1 数据传输的网络 - DAG
Day 2 - 4 如何在DAG上进行数据传输
Day 5 - 6 DAG如何形成的
数据结构与算法其实就是微观视角下的数据传输

# 2.1 数据结构: 四类结构

[509.斐波那契数](https://leetcode.cn/problems/fibonacci-number/description/)

![[Pasted image 20231021170143.png]]

![[2.1 数据结构_四类结构.mp4]]


DAG: [Directed acyclic graph](https://en.wikipedia.org/wiki/Directed_acyclic_graph)  有向无环图

## 数据结构
### 抽象: 逻辑结构
点和边的关系
边是有向的/无向的

A                       (有向)    ->        B
A的出度为1                   B的入度为1

A                         (无向)  -                B
A的度为1                         B的度为1


### 具体: 存储结构

## 分为四种
1. 集 (只有点0)
2. 图 (点和变随意连接)
3. 线 (序列): 不可有分支
4. 树 (子集点不能出现重叠): 度数 = 点数 - 1 ; 边 = 点 - 1;


## 概念作业
### 1. 数据结构的逻辑结构和存储结构的关系是什么?
抽象和具体的关系
### 2. 数据结构的逻辑结构的两要素是什么?
点和边 (可有有向/无向)
### 3. 树的边数与点数的关系是什么?
边数 = 点数 - 1 
点: 状态
边: 递推
### 4. 为什么所有的数据结构从值传递的角度来看都可以理解成DAG?
a. 线性结构和树形结构的值传递是DAG的简化版本
环图可以通过设置单调收敛的变量转换成DAG (环图为了避免重复访问一个点, 会设置is变量, 单调指的是vis只能从false变成true, 而反之不能; 熟练的意思是变成true后就不能继续变化了)
b. 题目举例:
	i. 求长度: DAG是最复杂的方案
		1 链表的长度
		2 树的最小深度和最大深度
		3 DAG的最短路径和最长路径
	ii. 指针翻转: DAG是最复杂的方案
		1 链表反转
		2 树的反转
		3 DAG的反转 
### 5. 常见的环图单调收敛算法; 最简单的环图收敛的例子是对于换图的每个点仅仅访问一次, 那么环图就变成了非环图
![[Pasted image 20231021174516.png]]

# 2.2 斐波那契: 先序FOR
![[2.2 斐波那契_先序FOR.mp4]] 

环图变成非环图: 引入单调收敛变量以保证其是一个DAG值传递
1. 转换关系
<u><font color = #00994C size = 5>所有数据结构从值传递的角度来看都是DAG</font></u>
2. 值传递的顺序
	先序: 已知 -> 未知
	后序: 位置 -> 已知
<u><font color = #00994C size = 5>先序和后序是适用于所有数据结构的</font></u>
3. 实现
	拓扑排序([Topological order](https://en.wikipedia.org/wiki/Topological_sorting)): [# 拓扑排序！（自讲）bilibili]( https://www.bilibili.com/video/BV1HL411E7TE/?spm_id_from=333.337.search-card.all.click&vd_source=c2e1aa56e950c5a8edda7fb95282ba1a)
	(可以不唯一)
<u><font color = #00994C size = 5>所有数据结构从拓扑排序的角度来说都是线性结构</font></u>


## 概念作业
## 1. 值传递的结构: 数据结构从值传递角度统一为DAG
### 2. 值传递的普适
a. 论文体系: 现代论文的引用体系
b. 前端: 数据响应式
c. 后端: 依赖注入
d. 数据库: 火山模型上的元组传递
e. 深度学习: 神经网络的前向传播与反向传播
### 3. 值传递的要素
1. 状态语义: f[i]无具体语义
	1. 边界状态:  f[0], f[1]
	2. 目标状态: f[n]
2. 递推公式: f[i] = f[i-1] + f[i-2]
3. 搜索方向: 注意本质上值传递都是从已知到未知
	1. 先序: 已知 - 未知: FOR BFD DFS
	2. 后序: 未知- 已知: DFS
### 4. 值传递的顺序:
	先序、后序 - 适用于所有数据结构 - 针对值传递
	二叉树 - 先序遍历和后序遍历 -有区别(后面提到)
	自顶向下& 自底向上 - 仅仅描述自上而下的树的值传递
### 5. 值传递的收敛:
大问题dp[n]只能依赖于小问题
快速排序和二分法的启发: 子问题不能依赖于原问题 - or变成死循环
[l,r] -> [l,m]&[m+l,r]
所有的死循环本质上就是没有把单调收敛好
### 6. 值传递的递推
dp问题的三种目标求值:
	1. 到达cur的最短路径: dp[cur] = min(dp[pre] + len[pre]‘[cur]): 假设边的长度为len[pre]''[cur]
	2. 到达cur的最长路径: dp[cur] = max(dp[pre] + len[pre]‘[cur]): 假设边的长度为len[pre]'['cur]
	3. 到达cur的路径个数: dp[cur] = sum(dp[pre] )
最短路径 - 成本最低的方案
最长路径 - 收益最大的方案
路径个数 - 符合条件的方案总数
### 7. 动规定义: 
动态规划(Dynamic programming): 把原问题分解为相对简单的子问题的方式求解复杂问题的方法
? 斐波那契是动态规划: 因为状态点的值传递构成了DAG图, 动态规划就是对DAG的搜索(后面课程会具体解释)
### 8. 问题改编: 
如果递推式是求前两个数的最大值会出现什么情况?如何解决?
	1. 会出现规律性的收敛, 这样题目就没有意义了,我们可以通过设置随机变量来对抗这种收敛
	2. 假设递推公式为dp[i] = max [dp[i-1]], dp[i-2], 那么序列就是0 1 1 1 1 1 1 1, 就没必要往后推了
	3. 假设递推公式为dp[i] = max [dp[i-1]], dp[i-2]*random, 这样才有递推下去的动力

## 代码作业
写出斐波那契的先序FOR代码

dp[i]一维数组
滚动数组 - 空间复杂度 O(1)

```python
class Solution:
def fib(self, n: int) -> int:

	p,q = 0,1
	for _ in range(n):
		p,q = q, p+q
	return p
```

ANS
```python
class Solution:
def fib(self, n: int) -> int:

	if n == 0 or n ==1:
		return n
	dp = [0,1]
	for i in range(2, n+1):
		dp.append(dp[i-1] + dp[i-2])
	return dp[n]
```



## 总结:
以后做值传递的题目, 列出[值传递的三要素](#3.值传递的要素) 就可以了

### 今日核心论点:
- 数据结构统一于DAG
- 算法统一于动态规划



